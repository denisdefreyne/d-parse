#!/usr/bin/env ruby

require 'd-parse'
require 'pp'

data = <<EOS
add(1, mul(2, 3))
mul(2,3)
EOS

include DParse::DSL

# primitives
digit = alt(*('0'..'9').map { |c| char(c) })
letter = alt(*('a'..'z').map { |c| char(c) })
lparen = char('(')
rparen = char(')')
comma = char(',')

# basic
identifier = seq(letter, repeat(letter)).capture.named('identifier')
lit = seq(digit, repeat(digit)).capture.map { |d| d.to_i(10) }
eof = seq(char("\n").opt, eof)
whitespace = repeat(whitespace_char)

# complex
funcall = nil
expression = alt(lazy { funcall }, lit).named('expression')
arglist_tail = repeat(seq(comma, whitespace, expression).map { |d| d[2] })
arglist = seq(expression, arglist_tail).map { |d| [d[0]] + d[1] }
funcall = seq(identifier, lparen, arglist, rparen).map { |d| [d[0]] + d[2] }
program = seq(expression.intersperse(char("\n")).select_even, eof).first

def eval_expr(expr)
  case expr
  when Array
    case expr[0]
    when 'add'
      eval_expr(expr[1]) + eval_expr(expr[2])
    when 'mul'
      eval_expr(expr[1]) * eval_expr(expr[2])
    else
      raise '???'
    end
  when Integer
    expr
  else
    raise '???'
  end
end

exprs = program.apply(data).data
pp exprs
exprs.each { |e| p eval_expr(e) }
