#!/usr/bin/env ruby

require 'd-parse'

Position = DParse::Position
Nothing  = DParse::Nothing
NOTHING  = DParse::NOTHING
Success  = DParse::Success
Failure  = DParse::Failure
Parser   = DParse::Parser

AnyParser         = DParse::Parsers::Any
CapturingParser   = DParse::Parsers::Capturing
CharParser        = DParse::Parsers::Char
EndOfInputParser  = DParse::Parsers::EndOfInput
IntersperseParser = DParse::Parsers::Intersperse
LazyParser        = DParse::Parsers::Lazy
NotCharParser     = DParse::Parsers::NotChar
NotCharsParser    = DParse::Parsers::NotChars
OrParser          = DParse::Parsers::Or
RepeatParser      = DParse::Parsers::Repeat
SequenceParser    = DParse::Parsers::Sequence
StringParser      = DParse::Parsers::String
WhitespaceParser  = DParse::Parsers::Whitespace

#############################################################################

digit =
  OrParser.new(
    *(('0'..'9').map { |c| CharParser.new(c) }),
  )

identifier_char =
  OrParser.new(
    *(('a'..'z').map { |c| CharParser.new(c) }),
  )

identifier =
  (identifier_char >> identifier_char.repeat).capture

lit =
  (digit >> digit.repeat).capture.map { |d| d.to_i(10) }

funcall = nil

expression =
  LazyParser.new { funcall } | lit

lparen = CharParser.new('(')
rparen = CharParser.new(')')
comma = CharParser.new(',')

arglist_tail =
  (comma >> WhitespaceParser.new >> expression).map { |d| d[2] }.repeat

arglist =
  (expression >> arglist_tail).map { |d| [d[0]] + d[1] }

funcall =
  (identifier >> lparen >> arglist >> rparen).map { |d| [d[0]] + d[2] }

##############################

def eval_expr(expr)
  case expr
  when Array
    case expr[0]
    when 'add'
      eval_expr(expr[1]) + eval_expr(expr[2])
    when 'mul'
      eval_expr(expr[1]) * eval_expr(expr[2])
    else
      raise '???'
    end
  when Integer
    expr
  else
    raise '???'
  end
end

expr = parse_from_argv(expression)

require 'pp'
pp expr

p eval_expr(expr)
